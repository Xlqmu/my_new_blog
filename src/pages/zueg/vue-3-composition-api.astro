---
import BaseHead from "../../components/BaseHead.astro";
import Footer from "../../components/Footer.astro";
import Header from "../../components/Header.astro";
import { SITE_TITLE } from "../../consts";
---

<!doctype html>
<html lang="zh-cn">
    <head>
        <BaseHead
            title={`Vue 3 Composition API 深入解析 - ${SITE_TITLE}`}
            description="掌握 Vue 3 的核心特性"
        />
    </head>
    <body>
        <Header />

        <main class="max-w-4xl mx-auto px-4 py-8">
            <div class="mb-8">
                <nav class="text-sm breadcrumbs">
                    <ul class="flex space-x-2 text-gray-600 dark:text-gray-400">
                        <li>
                            <a href="/" class="hover:text-blue-600">首页</a>
                        </li>
                        <li>></li>
                        <li>
                            <a href="/zueg" class="hover:text-blue-600">随笔</a>
                        </li>
                        <li>></li>
                        <li class="text-gray-900 dark:text-white">
                            Vue 3 Composition API
                        </li>
                    </ul>
                </nav>
            </div>

            <article class="prose dark:prose-invert max-w-none">
                <div class="text-center mb-12">
                    <img
                        src="/images/projects/vue-image.svg"
                        alt="Vue 3 Composition API"
                        class="w-32 h-32 mx-auto mb-6 rounded-lg shadow-lg"
                    />
                    <h1
                        class="text-4xl font-bold text-gray-900 dark:text-white mb-4"
                    >
                        Vue 3 Composition API 深入解析
                    </h1>
                    <div
                        class="flex items-center justify-center space-x-4 text-sm text-gray-500 dark:text-gray-400"
                    >
                        <span>📅 2025年8月14日</span>
                        <span>⏱️ 阅读时间 12 分钟</span>
                        <span
                            class="px-2 py-1 bg-green-100 dark:bg-green-900 text-green-800 dark:text-green-200 rounded-full"
                            >网站</span
                        >
                    </div>
                </div>

                <div
                    class="bg-green-50 dark:bg-green-900/20 rounded-lg p-6 mb-8"
                >
                    <h2
                        class="text-xl font-semibold text-green-900 dark:text-green-100 mb-3"
                    >
                        🚀 为什么选择 Composition API？
                    </h2>
                    <p class="text-green-800 dark:text-green-200">
                        Composition API 是 Vue 3
                        最重要的新特性之一，它提供了更好的逻辑复用、更清晰的代码组织和更好的
                        TypeScript 支持。
                    </p>
                </div>

                <h2>🔄 从 Options API 到 Composition API</h2>

                <h3>传统的 Options API</h3>
                <p>在 Vue 2 中，我们通常这样组织组件：</p>

                <div class="bg-gray-100 dark:bg-gray-800 rounded-lg p-4 mb-4">
                    <h4 class="font-semibold mb-2">Vue 2 风格：</h4>
                    <ul class="list-disc list-inside space-y-1 text-sm">
                        <li>data() 中定义响应式数据</li>
                        <li>methods 中定义方法</li>
                        <li>computed 中定义计算属性</li>
                        <li>watch 中定义侦听器</li>
                    </ul>
                </div>

                <h3>新的 Composition API</h3>
                <p>Vue 3 引入了 setup() 函数，所有逻辑都可以在这里组织：</p>

                <div class="bg-blue-100 dark:bg-blue-800 rounded-lg p-4 mb-6">
                    <h4 class="font-semibold mb-2">Vue 3 风格：</h4>
                    <ul class="list-disc list-inside space-y-1 text-sm">
                        <li>setup() 函数中统一管理</li>
                        <li>ref() 和 reactive() 创建响应式数据</li>
                        <li>computed() 创建计算属性</li>
                        <li>watch() 和 watchEffect() 创建侦听器</li>
                    </ul>
                </div>

                <h2>📝 核心概念详解</h2>

                <h3>1. 响应式数据</h3>

                <h4>ref() - 基本数据类型</h4>
                <p>用于创建响应式的基本数据类型：</p>
                <div class="space-y-2 mb-4">
                    <p><strong>用法：</strong></p>
                    <p>• 适用于 string, number, boolean 等基本类型</p>
                    <p>• 在模板中自动解包，在 JavaScript 中需要 .value</p>
                    <p>• 可以存储对象，但推荐使用 reactive()</p>
                </div>

                <h4>reactive() - 对象和数组</h4>
                <p>用于创建响应式的对象和数组：</p>
                <div class="space-y-2 mb-6">
                    <p><strong>特点：</strong></p>
                    <p>• 深层响应式，嵌套对象也会变成响应式</p>
                    <p>• 不需要 .value，直接访问属性</p>
                    <p>• 不能直接替换整个对象</p>
                </div>

                <h3>2. 计算属性与侦听器</h3>

                <h4>computed()</h4>
                <div
                    class="bg-purple-50 dark:bg-purple-900/20 border-l-4 border-purple-400 p-4 mb-4"
                >
                    <p class="text-purple-800 dark:text-purple-200">
                        <strong>计算属性的优势：</strong>
                    </p>
                    <ul
                        class="text-purple-700 dark:text-purple-300 mt-2 space-y-1"
                    >
                        <li>• 缓存机制，只有依赖变化时才重新计算</li>
                        <li>• 支持 getter 和 setter</li>
                        <li>• 自动依赖追踪</li>
                    </ul>
                </div>

                <h4>watch() vs watchEffect()</h4>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-6">
                    <div
                        class="bg-orange-50 dark:bg-orange-900/20 p-4 rounded-lg"
                    >
                        <h5
                            class="font-semibold text-orange-900 dark:text-orange-100 mb-2"
                        >
                            watch()
                        </h5>
                        <ul
                            class="text-orange-800 dark:text-orange-200 text-sm space-y-1"
                        >
                            <li>• 明确指定要监听的数据源</li>
                            <li>• 可以访问新值和旧值</li>
                            <li>• 惰性执行，初始不执行</li>
                            <li>• 更精确的控制</li>
                        </ul>
                    </div>
                    <div class="bg-teal-50 dark:bg-teal-900/20 p-4 rounded-lg">
                        <h5
                            class="font-semibold text-teal-900 dark:text-teal-100 mb-2"
                        >
                            watchEffect()
                        </h5>
                        <ul
                            class="text-teal-800 dark:text-teal-200 text-sm space-y-1"
                        >
                            <li>• 自动追踪响应式依赖</li>
                            <li>• 立即执行，无法访问旧值</li>
                            <li>• 更简洁的语法</li>
                            <li>• 适用于副作用逻辑</li>
                        </ul>
                    </div>
                </div>

                <h2>🛠️ 实用技巧和模式</h2>

                <h3>1. 逻辑复用</h3>
                <p>
                    Composition API
                    的最大优势之一是逻辑复用。可以将相关的逻辑抽取到组合函数中：
                </p>

                <div class="bg-gray-100 dark:bg-gray-800 rounded-lg p-4 mb-4">
                    <h4 class="font-semibold mb-2">组合函数示例：</h4>
                    <p class="text-sm">
                        创建 useCounter.js 文件，封装计数器逻辑
                    </p>
                </div>

                <h3>2. 生命周期钩子</h3>
                <p>在 Composition API 中，生命周期钩子需要从 vue 中导入：</p>

                <div class="space-y-2 mb-6">
                    <p><strong>主要钩子：</strong></p>
                    <ul class="list-disc list-inside space-y-1 ml-4">
                        <li>onMounted() - 组件挂载后</li>
                        <li>onUpdated() - 组件更新后</li>
                        <li>onUnmounted() - 组件卸载前</li>
                        <li>onBeforeMount() - 组件挂载前</li>
                    </ul>
                </div>

                <h3>3. 状态管理</h3>
                <p>
                    对于复杂的状态管理，可以结合 Pinia 或者使用 provide/inject：
                </p>

                <div
                    class="bg-indigo-50 dark:bg-indigo-900/20 rounded-lg p-4 mb-6"
                >
                    <h4
                        class="text-indigo-900 dark:text-indigo-100 font-semibold mb-2"
                    >
                        provide/inject 模式
                    </h4>
                    <p class="text-indigo-800 dark:text-indigo-200 text-sm">
                        适用于跨组件层级的数据传递，特别是在组件库开发中非常有用。
                    </p>
                </div>

                <h2>⚡ 性能优化技巧</h2>

                <h3>1. 合理使用 ref 和 reactive</h3>
                <div class="space-y-4">
                    <div class="flex items-start space-x-3">
                        <div
                            class="w-6 h-6 bg-green-500 rounded-full flex items-center justify-center mt-0.5"
                        >
                            <span class="text-white text-xs">✓</span>
                        </div>
                        <div>
                            <h4 class="font-semibold">推荐做法</h4>
                            <p class="text-gray-600 dark:text-gray-400">
                                基本类型用 ref()，对象用 reactive()
                            </p>
                        </div>
                    </div>

                    <div class="flex items-start space-x-3">
                        <div
                            class="w-6 h-6 bg-green-500 rounded-full flex items-center justify-center mt-0.5"
                        >
                            <span class="text-white text-xs">✓</span>
                        </div>
                        <div>
                            <h4 class="font-semibold">避免过度响应式</h4>
                            <p class="text-gray-600 dark:text-gray-400">
                                不需要响应式的数据可以放在 setup() 外部或使用
                                markRaw()
                            </p>
                        </div>
                    </div>
                </div>

                <h3>2. 合理使用计算属性</h3>
                <p>利用计算属性的缓存特性，避免不必要的重复计算。</p>

                <h3>3. 组件拆分</h3>
                <p>将大组件拆分为小组件，每个组件只关注自己的逻辑。</p>

                <h2>🔄 迁移策略</h2>

                <h3>渐进式迁移</h3>
                <p>不需要一次性重写所有组件，可以：</p>

                <div class="space-y-2 mb-6">
                    <ul class="list-disc list-inside space-y-1">
                        <li>新组件使用 Composition API</li>
                        <li>旧组件逐步迁移</li>
                        <li>两种 API 可以在同一个项目中共存</li>
                        <li>优先迁移复杂的、逻辑重复的组件</li>
                    </ul>
                </div>

                <h3>迁移工具</h3>
                <div class="bg-blue-50 dark:bg-blue-900/20 rounded-lg p-4 mb-6">
                    <p class="text-blue-800 dark:text-blue-200">
                        Vue 官方提供了 @vue/composition-api 插件，可以在 Vue 2.x
                        中使用 Composition API 进行提前适配。
                    </p>
                </div>

                <h2>🎯 最佳实践总结</h2>

                <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                    <div
                        class="bg-green-50 dark:bg-green-900/20 p-6 rounded-lg"
                    >
                        <h3
                            class="text-green-900 dark:text-green-100 font-semibold mb-4"
                        >
                            ✅ 推荐做法
                        </h3>
                        <ul
                            class="text-green-800 dark:text-green-200 space-y-2 text-sm"
                        >
                            <li>• 逻辑相关的代码放在一起</li>
                            <li>• 抽取公共逻辑为组合函数</li>
                            <li>• 使用 TypeScript 增强类型安全</li>
                            <li>• 合理利用响应式特性</li>
                            <li>• 保持组件单一职责</li>
                        </ul>
                    </div>

                    <div class="bg-red-50 dark:bg-red-900/20 p-6 rounded-lg">
                        <h3
                            class="text-red-900 dark:text-red-100 font-semibold mb-4"
                        >
                            ❌ 避免做法
                        </h3>
                        <ul
                            class="text-red-800 dark:text-red-200 space-y-2 text-sm"
                        >
                            <li>• 在 setup() 中进行异步操作</li>
                            <li>• 过度使用响应式包装</li>
                            <li>• 忽略生命周期钩子的执行顺序</li>
                            <li>• 在模板中进行复杂计算</li>
                            <li>• 忘记清理副作用</li>
                        </ul>
                    </div>
                </div>

                <h2>🚀 未来展望</h2>

                <p>
                    Composition API 不仅仅是语法上的变化，它代表了 Vue 3
                    的设计哲学转变。
                    通过更好的逻辑复用、更清晰的代码组织和更强的 TypeScript
                    支持， Composition API 让我们能够构建更维护的应用。
                </p>

                <div
                    class="bg-purple-50 dark:bg-purple-900/20 rounded-lg p-6 mt-8"
                >
                    <h3
                        class="text-purple-900 dark:text-purple-100 font-semibold mb-2"
                    >
                        🎓 学习建议
                    </h3>
                    <ol class="text-purple-800 dark:text-purple-200 space-y-1">
                        <li>1. 先理解响应式原理</li>
                        <li>2. 动手实践简单示例</li>
                        <li>3. 逐步迁移现有项目</li>
                        <li>4. 学习优秀的开源项目</li>
                        <li>5. 关注 Vue 生态系统更新</li>
                    </ol>
                </div>
            </article>
        </main>

        <Footer />
    </body>
</html>
