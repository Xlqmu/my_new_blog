---
title: '冒泡排序'
description: '深入理解二分查找算法的不同应用场景'
pubDate: '2025-07-28'
heroImage: '../../../assets/cover.svg'
category: '算法'
readingTime: 7
tags: ['算法', '冒泡排序', '数据结构', '编程']
---

核心思想：
重复地遍历列表，比较每对相邻的元素。如果它们的顺序不对（比如从小到大排序时，前一个比后一个大），就交换它们的位置。每完成一次完整的遍历，最大的那个元素就会被“冒”到正确的位置（末尾）。

这个过程会一直重复，直到没有任何一对元素需要交换，这说明整个列表已经有序了。

``` rust
// 需注意由于整个算法过程需要对数组进行重排，故需要可变
fn bubble_sort(arr: &mut Vec<i32>) { 
    // 获取数组的长度
    let n = arr.len();
    
    // 外层循环：控制遍历的轮数
    // 我们至多只需要 n-1 轮就可以完成排序
    for i in 0..n {
        // 内层循环：进行相邻元素的比较和交换
        // 每一轮结束后，末尾的元素已经就位，所以下一次内层循环可以少比较一次
        for j in 0..(n - i - 1) {
            // 逐一按序比较相邻元素
            // 如果 arr[j] 大于 arr[j+1]，就交换它们
            if arr[j] > arr[j + 1] {
                // 使用 Rust 的 `swap` 方法进行交换
                arr.swap(j, j + 1);
            }
        }
    }
}
```

冒泡排序虽然直观，但效率并不高（时间复杂度为 $O(n^2)$）

这是一个公式：
$O(n^2)$

---

好吧，公式渲染看来还有点问题，bug++
